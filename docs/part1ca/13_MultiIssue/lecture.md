Lecture 13
---

# More instruction-level parallelism. Multiple issue and out-of-order execution.

## Lecture

Slides ([PDF](CA_Lecture_13.pdf), [PPTX](CA_Lecture_13.pptx)).

#### Outline

* Multiple issue processors
* Dynamic and static scheduling
* Out-of-order execution

## Workshop

#### Outline

* System calls in RISC-V (additional topic related to exceptions)

##### System calls in RARS (RISC-V Assembly)

![System call](syscall.png)

System calls are exceptions generated by user code and serviced by the environment (operating system).
The environment executes the service code in kernel mode (has full access to all resources).
This code handles interaction with a specific device and its driver and returns control back to the user.

###### Standard (provided by all OS) system call supported by RARS: 

1. __open__ (1024): opens a file with the specified path

   _Input_: `a0` = Null terminated string for the path, `a1` = flags

   _Output_: `a0` = the file descriptor or -1 if an error occurred

   _Supported flags_: _read-only_ (0), _write-only_ (1), and _write-append_ (9).
   The _write-only_ flag creates a file if it does not exist, so it is technically _write-create_.
   The _write-append_ flag will start writing at end of an existing file.

1. __close__ (57): closes a file

   Input: `a0` = the file descriptor to close

   Output: N/A

1. __read__ (63): reads from a file descriptor into a buffer

   _Input_: `a0` = the file descriptor, `a1` = address of the buffer, `a2` = maximum length to read.

   _Output_: `a0` = the length read or -1 if error.

1. __write__ (64): writes to a file from a buffer

   _Input_: `a0` = the file descriptor, `a1` = the buffer address, `a2` = the length to write.

   _Output_: `a0` = the number of characters written.

1. __sbrk__ (9): allocates heap memory

   _Input_: `a0` = amount of memory in bytes

   _Output_: `a0` = address to the allocated block

#### Examples

* [file_write.s](file_write.s) - writing text to a file

Reading text from a file:

```assembly
  .data
fin:   
  .asciz "testouts.txt" # filename for input
error:
  .asciz "Error: failed to open a file."

buffer:
  .space 33

  .text
main:
  la   s0, buffer   # address of buffer to which to write
  li   s1, 32       # buffer size

  # Open (for reading) an existing file
  li   a7, 1024     # system call for open file
  la   a0, fin      # input file name
  li   a1, 0        # open for reading (flags are 0: read, 1: write)
  ecall             # open a file (file descriptor returned in a0)

  bltz a0, main.error # exit on errord exit
  mv   s6, a0        # save the file descriptor

main.loop:
  # Write to file just opened
  li   a7, 63       # system call for read from file
  mv   a0, s6       # file descriptor
  mv   a1, s0       # address of buffer to which to write
  mv   a2, s1       # buffer length
  ecall             # read from a file

  bltz a0, main.close # close the file on error and exit
  mv   t0, a0       # save size read 
  add  t1, s0, a0   # write zero terminator to end of buffer
  sb   zero, 0(t1)  #

  # Print the buffer read from a file
  li   a7, 4
  mv   a0, s0
  ecall

  # If bytes read = 32, loop. 
  beq  t0, s1, main.loop

main.close:
  # Close the file
  li   a7, 57       # system call for close file
  mv   a0, s6       # file descriptor to close
  ecall             # close file

main.exit:
  li   a7, 10
  ecall

main.error:
  li   a7, 4
  la   a0, error
  ecall
```

Allocating memory in the heap:

```assembly
  .macro new_line
    li a7, 11
    li a0, '\n'
    ecall
  .end_macro

  .macro sbrk(%bytes)
    li a7, 9
    li a0, %bytes
    ecall
  .end_macro

  .text
  # Allocates 16 bytes in the heap
  sbrk(16)
  li a7, 34
  ecall
  new_line

  # Allocates 32 bytes in the heap
  sbrk(32)
  li a7, 34
  ecall
  new_line

  # Allocates 64 bytes in the heap
  sbrk(64)
  li a7, 34
  ecall
  new_line
```

#### Tasks


## Homework

__TODO__

## References

__TODO__
